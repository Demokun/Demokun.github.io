# 300. 最长上升子序列
## https://leetcode-cn.com/problems/longest-increasing-subsequence
### 题目描述：  
	给定一个无序的整数数组，找到其中最长上升子序列的长度  
	示例:

	输入: [10,9,2,5,3,7,101,18]
	输出: 4
	解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
	说明:

	可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
	你算法的时间复杂度应该为 O(n2) 。
	进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?  
### 动态规划、数组
	dp（用于存储动态规划的结果）：
		dp[i] 表示以i结尾的最长上升子序列的长度
	结果的前后关系：
		以i结尾的最长上升子序列的长度 = dp[j] + 1；
		dp[j] 需要满足的条件：  
			1. dp[j]是排在i之前的最长上升子序列的长度（j < i)  
			2. 且该上升子序列在加入nums[i]之后仍是最长上升子序列(已知nums[j]是该子序列中的最大值，即nums[j] < nums[i])  
	算法思想：  	
		固定思路：
			创建dp[]数组，保存每个位置上的历史结果  
		结果产生：  
			在每次产生新dp[i]的值时更新max  
### 代码：
	    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int max = 1;
        dp[0] = 1;
        for (int i = 1; i < nums.length; i ++) {
            dp[i] = 1;
            for (int j = 0; j < i; j ++) {
                if (nums[i] > nums[j]) {
                    dp[i] = dp[i] > dp[j] ? dp[i] : dp[j] + 1;
                    max = max > dp[i] ? max : dp[i];
                }
            }
        }
        return max;
    }  


